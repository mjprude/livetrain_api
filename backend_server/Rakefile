require 'bundler'
Bundler.require

require 'sinatra/activerecord/rake'
require './connection'
require './mta_assets/gtfs-realtime.pb.rb'
require './mta_assets/nyct-subway.pb.rb'
require './modules/mta.rb'
require './models/trip.rb'
require './models/stop.rb'

ROOT_PATH = Dir.pwd
Dir[ROOT_PATH+"/lib/*.rb"].each{ |file| require file }
Dir[ROOT_PATH+"/helpers/*.rb"].each{ |file| require file }

namespace :db do
end

desc "Show Routes for This File"
task :routes do
  puts "******************"

  def capitalize_http(route)
    route
    .gsub('get', '    GET  ')
    .gsub('put', '    PUT  ')
    .gsub('patch', '  PATCH  ')
    .gsub('post', '   POST  ')
    .gsub('delete', ' DELETE  ')
  end

  def get_routes(path)
    route_regex = /(get|post|delete|patch|put) '\/.*(?= )/
    app = File.readlines(path)
    puts "Routes in #{path}\n******************"
    app.grep(route_regex).each do |line|
      puts capitalize_http(route_regex.match(line)[0])
    end
    puts "******************"
  end

  if File.exist?('app.rb')
    get_routes('app.rb')
  else
    Dir['./controllers/*.rb'].each{ |controller| get_routes(controller) }
  end

end

namespace :mta do

  ##########################################################
  # Use this task to retrieve MTA feed data
  ##########################################################
  desc 'run feed retriever'
  task :feed do

    # ************ Helper Methods *************
    def remove_alerts_and_vehicle_positions
      trip_updates = @transit_realtime_data[:entity].select {|entity| entity[:trip_update]}
      @transit_realtime_data[:entity] = trip_updates
    end

    def create_stops_from_entity(entity, trip_id)
      entity[:trip_update][:stop_time_update].each do |stop_update|
        Stop.create({
          trip_id: trip_id,
          stop_id: MTA::Stop.stop_id(stop_update),
          arrival_time: MTA::Stop.arrival_time(stop_update),
          departure_time: MTA::Stop.departure_time(stop_update),
          })
      end
    end

    # Get the raw data
    @transit_realtime_data = TransitRealtime::FeedMessage.parse(HTTParty.get("http://datamine.mta.info/mta_esi.php?key=#{ENV['MTA_REALTIME_API_KEY']}&feed_id=1")).to_hash
    ### Maybe come up with a way to handle situations where transit_realtime_data is not available?

    remove_alerts_and_vehicle_positions

    # Pull out the timestamp of the retrieved feed
    @feed_timestamp = MTA::Feed.mta_timestamp(@transit_realtime_data)

    # Pull out all mta_trip_ids from feed Trip Update entities into an array.
    @updated_trip_ids = @transit_realtime_data[:entity].map {|entity| MTA::Entity.mta_trip_id(entity) if entity[:trip_update]}.compact
    # Then iterate through each current trip, check to see if the id is included in the updates array.
    @updated_trips = []

    def parse_it_real_good
      Trip.all.each do |trip|
        unless trip.mta_timestamp == @feed_timestamp
          # Is there an updated stop timetable for this trip?
          if @updated_trip_ids.include?(trip.mta_trip_id)
            @updated_trips << trip.mta_trip_id
            # Update remaining stops in db
            trip.stops.each do |stop|
              if
            end
          else

          end
        end
      end
      # Deal with the last station info at this point.
    end



    # # Use the feed to update all entities
    # @transit_realtime_data[:entity].each do |entity|
    #   if entity[:trip_update]
    #     # Check to see if the update applies to any trips currently in the db
    #     if existing_trip = Trip.find_by({mta_trip_id: MTA::Entity.mta_trip_id(entity)})
    #       unless existing_trip.mta_timestamp == @feed_timestamp
    #         existing_stops = existing_trip.stops
    #         existing_stops.each do |stop|
    #           stop.destroy
    #         end
    #         create_stops_from_entity(entity, existing_trip.id)
    #       end
    #     else
    #       # If the trip doesn't exist yet, create it
    #       trip = Trip.create({
    #           mta_timestamp: @feed_timestamp,
    #           mta_trip_id: MTA::Entity.mta_trip_id(entity),
    #           stops_remaining: MTA::Entity.stops_remaining(entity),
    #           route: MTA::Entity.route(entity),
    #           direction: MTA::Entity.direction(entity),
    #         })
    #       create_stops_from_entity(entity, trip.id)
    #     end
    #   end
    # end

  def db_to_array
    Trip.all.map do |trip|
      current_time = Time.now
      stops = trip.stops.map do |stop|
        {
          stop_id: stop.stop_id,
          arrival_time: stop.arrival_time,
          departure_time: stop.departure_time,
        }
      end
      {
        trip_id: trip.mta_trip_id,
        timetable: stops,
      }
    end
  end

  binding.pry

  end

  desc 'get feed file'
  task :read do

  end
end