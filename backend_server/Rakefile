require 'bundler'
Bundler.require

require 'sinatra/activerecord/rake'
require './connection'
require './mta_assets/gtfs-realtime.pb.rb'
require './mta_assets/nyct-subway.pb.rb'
require './modules/mta.rb'
require './models/trip.rb'
require './models/stop.rb'

ROOT_PATH = Dir.pwd
Dir[ROOT_PATH+"/lib/*.rb"].each{ |file| require file }
Dir[ROOT_PATH+"/helpers/*.rb"].each{ |file| require file }

namespace :db do
end

desc "Show Routes for This File"
task :routes do
  puts "******************"

  def capitalize_http(route)
    route
    .gsub('get', '    GET  ')
    .gsub('put', '    PUT  ')
    .gsub('patch', '  PATCH  ')
    .gsub('post', '   POST  ')
    .gsub('delete', ' DELETE  ')
  end

  def get_routes(path)
    route_regex = /(get|post|delete|patch|put) '\/.*(?= )/
    app = File.readlines(path)
    puts "Routes in #{path}\n******************"
    app.grep(route_regex).each do |line|
      puts capitalize_http(route_regex.match(line)[0])
    end
    puts "******************"
  end

  if File.exist?('app.rb')
    get_routes('app.rb')
  else
    Dir['./controllers/*.rb'].each{ |controller| get_routes(controller) }
  end

end

namespace :mta do

  ##########################################################
  # Use this task to retrieve MTA feed data every 30 seconds
  ##########################################################
  desc 'run feed retriever'
  task :feed do
    # loop do

    current_time = Time.now
    date, time, zone = current_time.to_s.split(' ')
    string = "./mta_assets/feeds/#{@feedA ? 'feedA' : 'feedB'}/" + date + "_" + time.gsub(':', '.') + "_" + 'realtime.json'

    @transit_realtime_data = TransitRealtime::FeedMessage.parse(HTTParty.get("http://datamine.mta.info/mta_esi.php?key=#{ENV['MTA_REALTIME_API_KEY']}&feed_id=1")).to_hash
    ###
    ### Maybe come up with a way to handle situations where transit_realtime_data is not available?
    ###

    def remove_alerts_and_vehicle_positions
      trip_updates = @transit_realtime_data[:entity].select {|entity| entity[:trip_update]}
      @transit_realtime_data[:entity] = trip_updates
    end

    remove_alerts_and_vehicle_positions

    @feed_timestamp = MTA::Feed.mta_timestamp(@transit_realtime_data)

    @transit_realtime_data[:entity].each do |entity|

      trip = Trip.create({
          mta_timestamp: @feed_timestamp,
          mta_trip_id: MTA::Entity.mta_trip_id(@raw_trip),
          stops_remaining: MTA::Entity.stops_remaining(@raw_trip),
          route: MTA::Entity.route(@raw_trip),
          direction: MTA::Entity.direction(@raw_trip),
        })

      entity[:trip_update][:stop_time_update].each do |stop_update|
        Stop.create({
          trip_id: @test_trip.id,
          stop_id: MTA::Stop.stop_id(stop_update),
          arrival_time: MTA::Stop.departure_time(stop_update),
          departure_time: MTA::Stop.arrival_time(stop_update),
          })
      end

    end



    # @raw_trip = @transit_realtime_data[:entity][0]


    # @raw_trip[:trip_update][:stop_time_update].each do |stop_update|
    #   Stop.create({
    #       trip_id: @test_trip.id,
    #       stop_id: MTA::Stop.stop_id(stop_update),
    #       arrival_time: MTA::Stop.departure_time(stop_update),
    #       departure_time: MTA::Stop.arrival_time(stop_update),
    #     })
    # end

    binding.pry
  end


end