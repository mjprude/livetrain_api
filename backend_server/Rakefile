require 'bundler'
Bundler.require

require 'sinatra/activerecord/rake'
require './connection'
require './mta_assets/gtfs-realtime.pb.rb'
require './mta_assets/nyct-subway.pb.rb'
require './modules/mta.rb'
require './models/trip.rb'
require './models/stop.rb'

ROOT_PATH = Dir.pwd
Dir[ROOT_PATH+"/lib/*.rb"].each{ |file| require file }
Dir[ROOT_PATH+"/helpers/*.rb"].each{ |file| require file }

namespace :db do

  desc 'Deletes all trips and stops from database'
  task :clear_trips do
    conn = PG.connect({
      dbname: 'mta_realtime'
      })
    conn.exec('DELETE FROM trips;')
    conn.exec('DELETE FROM stops;')
    conn.close
  end

end

desc "Show Routes for This File"
task :routes do
  puts "******************"

  def capitalize_http(route)
    route
    .gsub('get', '    GET  ')
    .gsub('put', '    PUT  ')
    .gsub('patch', '  PATCH  ')
    .gsub('post', '   POST  ')
    .gsub('delete', ' DELETE  ')
  end

  def get_routes(path)
    route_regex = /(get|post|delete|patch|put) '\/.*(?= )/
    app = File.readlines(path)
    puts "Routes in #{path}\n******************"
    app.grep(route_regex).each do |line|
      puts capitalize_http(route_regex.match(line)[0])
    end
    puts "******************"
  end

  if File.exist?('app.rb')
    get_routes('app.rb')
  else
    Dir['./controllers/*.rb'].each{ |controller| get_routes(controller) }
  end

end

namespace :mta do

  ##########################################################
  # Use this task to retrieve MTA feed data
  ##########################################################
  desc 'run feed retriever'
  task :feed do

    # ************ Helper Methods *************
    def create_stops_from_entity(entity, trip)
      entity[:trip_update][:stop_time_update].each do |stop_update|
        Stop.create({
          trip_id: trip.id,
          stop_id: MTA::Stop.stop_id(stop_update),
          arrival_time: MTA::Stop.arrival_time(stop_update),
          departure_time: MTA::Stop.departure_time(stop_update),
          })
      end
    end

    def update_existing_stops(entity, trip)
      entity[:trip_update][:stop_time_update].each do |stop_update|
        stop = trip.stops.find_by({stop_id: MTA::Stop.stop_id(stop_update)})
        stop.update({
          arrival_time: MTA::Stop.arrival_time(stop_update),
          departure_time: MTA::Stop.departure_time(stop_update),
        })
      end
    end

    # Get the raw data
    @transit_realtime_data = TransitRealtime::FeedMessage.parse(HTTParty.get("http://datamine.mta.info/mta_esi.php?key=#{ENV['MTA_REALTIME_API_KEY']}&feed_id=1")).to_hash
    ### Maybe come up with a way to handle situations where transit_realtime_data is not available?

    # Pull out the timestamp of the retrieved feed
    @feed_timestamp = MTA::Feed.mta_timestamp(@transit_realtime_data)




    # Pull out count of trip_update Feed Entities
    @updated_trips = @transit_realtime_data[:entity].count {|entity| entity[:trip_update] }

    # Then iterate through each current trip in db
    @num_created_trips = 0 # PURELY FOR DEBUGGING !!!
    @num_updated_trips = 0 # PURELY FOR DEBUGGING !!!




    # Use the feed to update all entities
    @transit_realtime_data[:entity].each do |entity|
      if entity[:trip_update]
        # Check to see if the update applies to any trips currently in the db
        if existing_trip = Trip.find_by({mta_trip_id: MTA::Entity.mta_trip_id(entity)})
          unless existing_trip.mta_timestamp == @feed_timestamp
            @num_updated_trips += 1 # PURELY FOR DEBUGGING !!!
            existing_trip.update({
              mta_timestamp: @feed_timestamp,
              stops_remaining: MTA::Entity.stops_remaining(entity)
              })
            update_existing_stops(entity, existing_trip)
          end
        else
          # If the trip doesn't exist yet, create it
          @num_created_trips += 1 # PURELY FOR DEBUGGING !!!
          new_trip = Trip.create({
              mta_timestamp: @feed_timestamp,
              mta_trip_id: MTA::Entity.mta_trip_id(entity),
              stops_remaining: MTA::Entity.stops_remaining(entity),
              route: MTA::Entity.route(entity),
              direction: MTA::Entity.direction(entity),
            })
          create_stops_from_entity(entity, new_trip)
        end
      end
    end

    @deletions = 0
    Trip.where('stops_remaining < ?', 3).each do |trip|
      if Time.now.to_i > trip.mta_timestamp + 120
        @deletions += 1
        trip.destroy
      end
    end

    future_trips = Trip.select do |trip|
      current_time = Time.now.to_i
      future_departures = trip.stops.where('departure_time > ?',  current_time).order('departure_time ASC')
      if future_departures.empty?
        false
      else
        future_departures.first.departure_time - Time.now.to_i > 400
      end
    end

    # Use this in case you need to debug the cleanup...

    # @suggested_deletions = []
    # @possible_deletions = Trip.where('stops_remaining < ?', 3)
    # @possible_deletions.each do |possible_deletion|
    #   if Time.now.to_i > possible_deletion.mta_timestamp + 120
    #     @suggested_deletions << possible_deletion
    #   end
    # end

    puts "Total MTA Updates: #{@updated_trips}"
    puts "Created trips: #{@num_created_trips}"
    puts "Updated trips: #{@num_updated_trips}"
    puts "Deleted trips: #{@deletions}"
    puts "     DB trips: #{Trip.all.count}"

    binding.pry
  end
end